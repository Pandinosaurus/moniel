class Graph extends React.Component{

    constructor(props) {
        console.log("constructor");
        super(props);

        this.graph = new dagreD3.graphlib.Graph()
            .setGraph({})
            .setDefaultEdgeLabel(function() { return {}; });

        this.dagreRenderer = new dagreD3.render();

        this.walkAst = this.walkAst.bind(this);
        var customHash = function(str) {
            var hash = 0;
            for(var i = 0; i < str.length; i++) {
                hash += str.charCodeAt(i) % 47;
            }
            return hash;
        };

        var customHash = function(str) {
            var hash = 11;
            for (var i = 0; i < str.length; i++) {
                hash = hash * 47 + str.charCodeAt(i) % 32;
            }
            return hash
        }
        this.colorHash = new ColorHash({saturation: [0.9], lightness: [0.45], hash: customHash});
        this.lineInterpolate = "basis";
    }

    componentDidMount() {

        /*
        this.zoom = d3.behavior.zoom().on("zoom", function() {
            //console.log(d3.event.translate, d3.event.scale);
            console.log(d3.select(this.svgGroup));
                d3.select(this.svgGroup).attr("transform", "translate(" + d3.event.translate + ")" + "scale(" + d3.event.scale + ")");
            });

        d3.select(this.svg).call(this.zoom);
        */
    }

    componentWillReceiveProps(nextProps) {
        // console.log("componentWillReceiveProps");
        this.ast = nextProps.ast;
    }

    generateGraph(ast) {
        // console.log("generateGraph")
        var graph = new dagreD3.graphlib.Graph()
            .setGraph({})
            .setDefaultEdgeLabel(function() { return {}; });

        this.nodeCounter = {};
        this.previousItem = null;

        this.blockDefinitions = ["Input", "KatarinaLajtosova", "Output", "Convolution", "BatchNormalization", "Identity", "RectifiedLinearUnit", "Summation", "Dropout"];
        extractDefinitionsFromAST(this.ast, this.blockDefinitions)

        this.walkAst(this.ast, graph);

        return graph;
    }

    generateIdentifier(blockName) {
        if (this.nodeCounter.hasOwnProperty(blockName)) {
            this.nodeCounter[blockName] += 1;
        } else {
            this.nodeCounter[blockName] = 1;
        }
        return blockName + this.nodeCounter[blockName];
    }

    walkAst(node, graph) {
        if (!node) {
            return;
        }
        switch (node.type) {
            case "Network":
                // node.definitions.map(definition => console.log(definition, graph));
                node.definitions.forEach(function(definition) {
                    this.walkAst(definition, graph);
                }, this);
                break;
            case "Connection":
                node.list.forEach(function(item){
                    this.walkAst(item, graph);
                    this.previousItem = item;
                }, this);
                this.previousItem = null;
                break;
            case "BlockInstance":
                var block = nameResolution(node.name, this.blockDefinitions);
                var type, label, shape;

                if (block.length === 0) {
                    type = "undefined";
                    label = node.name;
                    shape = "rect";
                    // annotate source -> unrecognized block type
                } else if (block.length === 1) {
                    type = block[0];
                    label = block[0];
                    shape = "rect";
                } else {
                    type = "ambiguous"
                    label = node.name
                    shape = "diamond";
                    // annotate source -> ambiguous block name, show possible matches
                }

                if (!node.alias) {
                    node.alias = {
                        "type": "Identifier",
                        "value": this.generateIdentifier(label),
                        "autogenerated": true
                    }
                }

                var color = this.colorHash.hex(label);

                graph.setNode(node.alias.value, {label: label, rx: 5, ry: 5, class: type, shape: shape, labelStyle: "fill: white", style: "fill: " + color});
                
                if (this.previousItem) {
                    
                    if (this.previousItem.type === "Identifier") {
                        graph.setEdge(this.previousItem.value, node.alias.value, {lineInterpolate: this.lineInterpolate});
                    } else if (this.previousItem.type === "BlockInstance") {
                        graph.setEdge(this.previousItem.alias.value, node.alias.value, {lineInterpolate: this.lineInterpolate});   
                    } else if (this.previousItem.type === "BlockList") {
                        this.previousItem.list.forEach(function(item) {
                            if (item.type === "BlockInstance") {
                                graph.setEdge(item.alias.value, node.alias.value, {lineInterpolate: this.lineInterpolate});
                            } else if (item.type === "Identifier") {
                                graph.setEdge(item.value, node.alias.value, {lineInterpolate: this.lineInterpolate});
                            }
                        }, this);
                    }
                }
                break;
            case "BlockList":
                node.list.forEach(function(item){
                    this.walkAst(item, graph);
                }, this);
                break;
            case "Identifier":
                // 

                if (!graph.hasNode(node.value)) {
                    console.warn("Unresolved identifier - ", node.value);
                    var color = this.colorHash.hex(node.value);

                   graph.setNode(node.value, {label: node.value, class: "type-identifier", style: "fill: " + color}); 
                }

                if (this.previousItem) {

                    if (this.previousItem.type === "Identifier") {
                        graph.setEdge(this.previousItem.value, node.value, {lineInterpolate: this.lineInterpolate});
                    } else if (this.previousItem.type === "BlockInstance") {
                        graph.setEdge(this.previousItem.alias.value, node.value, {lineInterpolate: this.lineInterpolate});
                    } else if (this.previousItem.type === "BlockList") {
                        this.previousItem.list.forEach(function(item) {
                            if (item.type === "BlockInstance") {
                                graph.setEdge(item.alias.value, node.value, {lineInterpolate: this.lineInterpolate});
                            } else if (item.type === "Identifier") {
                                graph.setEdge(item.value, node.value, {lineInterpolate: this.lineInterpolate});
                            }
                        }, this);
                    }
                }

                break;
            case "BlockDefinition":
                console.log(node);
                if (!this.blockDefinitions.includes(node.name)) {
                    this.blockDefinitions.push(node.name);
                }
                break;
        }
    }

    render() {
        // console.log("rendering", this.props.ast);
        if (this.svg && this.props.ast) {
            var graph = this.generateGraph(this.props.ast);
            var svg = d3.select(this.svg)
            var group = d3.select(this.svgGroup)

            graph.graph().transition = function(selection) {
                return selection.transition().duration(500);
            };

            this.dagreRenderer(d3.select(this.svgGroup), graph);

            group.selectAll("g.node")
                .on("mouseover", function(d) {
                    console.log(d);
                });


            var graphWidth = graph.graph().width + 20;
            var graphHeight = graph.graph().height + 20;
            var width = this.svg.getBoundingClientRect().width
            var height = this.svg.getBoundingClientRect().height
            var zoomScale = Math.min(width / graphWidth, height / graphHeight);
            var translate = [((width/2) - ((graphWidth*zoomScale)/2)), ((height/2) - (graphHeight*zoomScale)/2)];

            //group.translate(translate);
            //group.scale(zoomScale);

            // center
            d3.select(this.svgGroup).transition().duration(250).attr("transform", "translate(" + translate + ")scale(" + zoomScale + ")");
        }

        var style = {flex: 1, margin: "1em"}

        return <svg id="vizualization" style={style} ref={(ref) => this.svg = ref}>
            <g id="group" ref={(ref) => this.svgGroup = ref}></g>
        </svg>;
    }
}