class Graph extends React.Component{

    constructor(props) {
        console.log("constructor");
        super(props);

        this.dagreRenderer = new dagreD3.render();

        this.walkAst = this.walkAst.bind(this);
        this.defaultEdge = {
            arrowhead: "vee",
            lineInterpolate: "basis"
        }
    }

    getDefaultEdge() {
        return JSON.parse(JSON.stringify(this.defaultEdge));
    }

    componentDidMount() {

        /*
        this.zoom = d3.behavior.zoom().on("zoom", function() {
            //console.log(d3.event.translate, d3.event.scale);
            console.log(d3.select(this.svgGroup));
                d3.select(this.svgGroup).attr("transform", "translate(" + d3.event.translate + ")" + "scale(" + d3.event.scale + ")");
            });

        d3.select(this.svg).call(this.zoom);
        */
    }

    componentWillReceiveProps(nextProps) {
        // console.log("componentWillReceiveProps");
        this.ast = nextProps.ast;
    }

    generateGraph(ast) {
        // console.log("generateGraph")
        var graph = new dagreD3.graphlib.Graph({compound:true})
            .setGraph({})
            .setDefaultEdgeLabel(function() { return {}; });

        this.nodeCounter = {};
        this.previousItem = null;

        this.scopeStack = [];

        this.blockDefinitions = [
            "Add",
            "Input",
            "Output",
            "Placeholder",
            "Variable",
            "Constant",
            "Multiply",
            "Convolution",
            "Dense",
            "MaxPooling",
            "BatchNormalization",
            "Identity",
            "RectifiedLinearUnit",
            "Sigmoid",
            "ExponentialLinearUnit",
            "Tanh",
            "Absolute",
            "Summation",
            "Dropout",
            "MatrixMultiply",
            "BiasAdd",
            "Reshape",
            "Concat",
            "Flatten",
            "Tensor",
            "Softmax",
            "CrossEntropy"
        ];
        extractDefinitionsFromAST(this.ast, this.blockDefinitions)

        this.walkAst(this.ast, graph);

        return graph;
    }

    generateIdentifier(scopeStack, node, type) {
        var scope = scopeStack.join("/");
        var id = scope + "/" + type;

        if (node.type === "BlockInstance") {
            if (!node.alias) {
                if (this.nodeCounter.hasOwnProperty(id)) {
                    this.nodeCounter[id] += 1;
                } else {
                    this.nodeCounter[id] = 1;
                }
                id = scope + "/" + type + this.nodeCounter[id];
            } else {
                id = scope + "/" + node.alias.value;
            }
        } else if (node.type === "Identifier") {
            id = scope + "/" + node.value;
        } else if (node.type === "Scope") {
            id = scope;
        } else {
            console.warn("uf!", node);
        }

        //console.log("nove ID:", id);

        return id;
    }

    walkAst(node, graph) {
        // console.log(node.type);
        if (!node) {
            return;
        }
        switch (node.type) {
            case "Network":
                this.scopeStack.push(".");
                graph.setNode(this.scopeStack.join("/"), {class: "Network"});
                node.definitions.forEach(function(definition) {
                    this.walkAst(definition, graph);
                }, this);
                break;
            case "Connection":
                node.list.forEach(function(item){
                    this.walkAst(item, graph);
                    this.previousItem = item;
                }, this);
                this.previousItem = null;
                break;
            case "BlockInstance":
                var block = nameResolution(node.name, this.blockDefinitions);
                var type, label, shape, color, id;

                if (block.length === 0) {
                    type = "undefined";
                    label = node.name;
                    shape = "rect";
                    console.log("Unknown block type");
                } else if (block.length === 1) {
                    type = block[0];
                    label = block[0];
                    shape = "rect";
                    color = colorHash.hex(label);
                } else {
                    type = "ambiguous"
                    label = node.name
                    shape = "diamond";
                    console.log("ambiguous block type; possible matches:", block);
                }

                var id = this.generateIdentifier(this.scopeStack, node, type);

                if (!node.alias) {
                    node.alias = {
                        "type": "Identifier",
                        "value": id,
                        "autogenerated": true
                    }
                } else {
                    node.alias.value = id;
                    label = node.alias.value;
                }

                graph.setNode(node.alias.value, {
                    label: label,
                    class: type,
                    shape: shape,
                    style: "fill: " + color,
                    _interval: node._interval
                });
                graph.setParent(node.alias.value, this.scopeStack.join("/"));
                
                if (this.previousItem) {
                    
                    if (this.previousItem.type === "Identifier") {
                        graph.setEdge(this.previousItem.value, node.alias.value, this.getDefaultEdge());
                    } else if (this.previousItem.type === "BlockInstance") {
                        graph.setEdge(this.previousItem.alias.value, node.alias.value, this.getDefaultEdge());   
                    } else if (this.previousItem.type === "BlockList") {
                        this.previousItem.list.forEach(function(item) {
                            if (item.type === "BlockInstance") {
                                graph.setEdge(item.alias.value, node.alias.value, this.getDefaultEdge());
                            } else if (item.type === "Identifier") {
                                graph.setEdge(item.value, node.alias.value, this.getDefaultEdge());
                            }
                        }, this);
                    }
                }
                break;
            case "BlockList":
                node.list.forEach(function(item){
                    this.walkAst(item, graph);
                }, this);
                break;
            case "Identifier":
                var id = this.generateIdentifier(this.scopeStack, node, null);
                if (!graph.hasNode(id)) {
                    console.warn("Unresolved identifier - ", id, node);
                    node.value = id;

                    graph.setNode(id, {
                        label: node.value,
                        rx: 5, ry: 5,
                        class: "undefined"
                    });
                    graph.setParent(node.value, this.scopeStack.join("/"));
                } else {
                    node.value = id;
                }

                if (this.previousItem) {

                    if (this.previousItem.type === "Identifier") {
                        graph.setEdge(this.previousItem.value, node.value, this.getDefaultEdge());
                    } else if (this.previousItem.type === "BlockInstance") {
                        graph.setEdge(this.previousItem.alias.value, node.value, this.getDefaultEdge());
                    } else if (this.previousItem.type === "BlockList") {
                        this.previousItem.list.forEach(function(item) {
                            if (item.type === "BlockInstance") {
                                graph.setEdge(item.alias.value, node.value, this.getDefaultEdge());
                            } else if (item.type === "Identifier") {
                                graph.setEdge(item.value, node.value, this.getDefaultEdge());
                            }
                        }, this);
                    }
                }

                break;
            case "BlockDefinition":
                if (!this.blockDefinitions.includes(node.name)) {
                    this.blockDefinitions.push(node.name);
                }
                break;
            case "Scope":
                console.log(node.type, node);

                var previousScopeId = this.generateIdentifier(this.scopeStack, node, null);
                this.scopeStack.push(node.name);
                var scopeId = this.generateIdentifier(this.scopeStack, node, null);

                graph.setNode(scopeId, {
                    label: node.name,
                    clusterLabelPos: 'top',
                    class: "Scope"
                });
                graph.setParent(scopeId, previousScopeId);

                if (node.body) {
                    this.walkAst(node.body, graph);
                }

                this.scopeStack.pop();
                break;
            case "ScopeBody":
                console.log(node.type, node);
                if (node.definitions) {
                    node.definitions.forEach(function(definition) {
                        this.walkAst(definition, graph);
                    }, this);
                } else {
                    console.info("Empty scope.");
                }
                break;
            default:
                console.warn("Unrecognized Block", node);
        }
    }

    render() {
        // console.log("rendering", this.props.ast);
        if (this.svg && this.props.ast) {
            var graph = this.generateGraph(this.props.ast);
            var svg = d3.select(this.svg)
            var group = d3.select(this.svgGroup)

            graph.graph().transition = function(selection) {
                return selection.transition().duration(250);
            };

            graph.setGraph({
                rankdir: 'BT',
                edgesep: 20,
                ranksep: 40,
                nodeSep: 20,
                marginx: 20,
                marginy: 20
            })
            dagre.layout(graph);

            this.dagreRenderer(d3.select(this.svgGroup), graph);

            var nodes = group.selectAll("g.node");

            nodes.on("click", function(d) {
                var node = graph.node(d);
                this.props.onHighlight({
                    startIdx: node._interval.startIdx,
                    endIdx: node._interval.endIdx
                });
            }.bind(this));


            var graphWidth = graph.graph().width;
            var graphHeight = graph.graph().height;
            var width = this.svg.getBoundingClientRect().width
            var height = this.svg.getBoundingClientRect().height
            var zoomScale = Math.min(width / graphWidth, height / graphHeight);
            var translate = [((width/2) - ((graphWidth*zoomScale)/2)), ((height/2) - (graphHeight*zoomScale)/2)];

            //group.translate(translate);
            //group.scale(zoomScale);

            // center
            d3.select(this.svgGroup).transition().duration(250).attr("transform", "translate(" + translate + ")scale(" + zoomScale + ")");
        }

        var style = {flex: 1}

        return <svg id="vizualization" style={style} ref={(ref) => this.svg = ref}>
            <g id="group" ref={(ref) => this.svgGroup = ref}></g>
        </svg>;
    }
}